

#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp> // OpenCV Core Functionality
#include <opencv2/highgui/highgui.hpp> // High-Level Graphical User Interface
#include <opencv2/video.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <math.h>       /* sqrt */
#include <ctime>
#include <cstdlib>

using namespace cv;
using namespace std;

// Class declaration for RANSAC generated lines

class Lines {
public:
	Point point1, point2;
	int count;
	float slope, intercept;
};



// Function to perform RANSAC (calls on other functions for support)
void myRansac(int& k, float& t, vector<Point>& points, vector<Lines>& goodlines);

// Function to count points that are inliers
void countInliers(vector<Point>& points, int& r1, int& r2, float& t, vector<Lines>& goodlines);

// Function to check the uniqueness of line generated by random points
int checkUnique(float& slopefudge, float& intfudge, float& slope, float& intercept, vector<Lines>& goodlines);

// Function to be used for drawing good lines
void drawLines(vector<Lines>& goodlines, int& numlines, Mat& img1);


int main()
{

	Mat img1, edge;
	//int thresh1 = 90;
	int rows, cols;

	img1 = imread("../Pictures/road_4.jpeg", 0);
	blur(img1, img1, Size(3, 3));
	
	imshow("Input", img1);
	waitKey();
	Canny(img1, edge, 160, 340);
	imshow("Edges", edge);
	waitKey();

	//rows = edge.rows;
	//cols = edge.cols;
	//cout << rows << "x" << cols << endl;
	
	float t = 0.8;
	int num = 4;
	vector<Point> points;
	findNonZero(edge, points);
	int k = 600;//points.size();
	cout << points.size() << endl;
	vector<Lines> goodlines;
	myRansac(k, t, points, goodlines);
	drawLines(goodlines, num, img1);
	
}


void myRansac(int& k, float& t, vector<Point>& points, vector<Lines>& goodlines)
{
	srand(time(0));
	cout << goodlines.size() << endl;
	for (int q = 0; q < k; q++)
	{
		int r1 = rand() % points.size() + 1;
		int r2 = rand() % points.size() + 1;
		countInliers(points, r1, r2, t, goodlines);
	}
	cout << goodlines.size() << endl;
}


void countInliers(vector<Point>& points, int& r1, int& r2, float& t, vector<Lines>& goodlines)
{
	float y1 = points[r1].y;
	float y2 = points[r2].y;
	float x1 = points[r1].x;
	float x2 = points[r2].x;

	float slope = (y2 - y1) / (x2 - x1);
	float intercept = y2 - (slope * x2);

	float slopefudge = 0.15;
	float intfudge = 50;
	
	if (checkUnique(slopefudge, intfudge, slope, intercept, goodlines))
	{
		int count = 0;

		for (int j = 0; j < points.size(); j++)
		{

			float y0 = points[j].y;
			float x0 = points[j].x;

			float dist = abs(((y2 - y1) * x0) - ((x2 - x1) * y0) + (x2 * y1) - (y2 * x1)) / sqrt(pow((y2 - y1), 2) + pow((x2 - x1), 2));

			if (dist < t)
				count++;
		}
		Lines temp;
		temp.point1 = points[r1];
		temp.point2 = points[r2];
		temp.count = count;
		temp.slope = slope;
		temp.intercept = intercept;
		goodlines.push_back(temp);
	}
}


// Check if the line described by random points is unique
int checkUnique(float& slopefudge, float& intfudge, float& slope, float& intercept, vector<Lines>& goodlines)
{

	for (int j = 0; j < goodlines.size(); j++)
	{
		if ((goodlines[j].slope - slopefudge) <= slope && slope <= (goodlines[j].slope + slopefudge) && (goodlines[j].intercept - intfudge) <= intercept && intercept <= (goodlines[j].intercept + intfudge))
			return 0;
	}
	return 1;

}


// Drawing lines function
void drawLines(vector<Lines>& goodlines, int& numlines, Mat& img)
{
	int max = 0;
	int maxindex = 0;
	Mat overlay = Mat::zeros(img.rows, img.cols, CV_8UC1);
	//cvtColor(img1, overlay, COLOR_GRAY2BGR);
	overlay = img;

	for (int n = 0; n < numlines; n++)
	{
		for (int i = 0; i < goodlines.size(); i++)
		{
			if (goodlines[i].count > max)
			{
				max = goodlines[i].count;
				maxindex = i;
			}
		}
		if (goodlines[maxindex].slope != INFINITY)
		{
			line(overlay, goodlines[maxindex].point1, goodlines[maxindex].point2, Scalar(1), 2, LINE_8);
			goodlines.erase(goodlines.begin() + maxindex);
			max = 0;
			maxindex = 0;
		}
		else
		{
			n = n - 1;
		}

	}
	cout << goodlines.size() << endl;
	imshow("Overlay", overlay);
	waitKey();
	imwrite("Lane_Line_4.png", overlay);
}
